---
title: "Record Webhooks"
description: "How to use Record Webhooks to get data into your system"
---

## Overview
Record Webhooks are sent to your servers in real-time as the user is submitting the Importer. Due to the real-time nature of Record webhooks, they should only be used if:
- You need the data for each Import in your system **before the user exits the Importer**.
- You need to pass back-end data validation issues back to the user (note: in many cases, the [Fuse validations](/getting-started/adding-data-validations/) are sufficient and it is not necessary to use your back-end validations)

Each Record Webhook sent to your server will contain a **batch** of records (up to 1000 records). An import with 10,000 records will have ten Record Webhooks sent, each with a batch of 1000 records.
Record Webhooks send records in batches. Each batch has up to 1000 records in it.

## Record Webhook Flow
There are three steps that you need to set up to get Record Webhooks working properly.

### Step 1: Fuse send batches of records to the external webhook
Fuse will send records to your webhook in **batches** of 1000. The payload looks like this:

```javascript
{
  batch_slug: '77db4861-6205-4344-b234-2d3ca0f9439a',
  import_slug: '960e938b-b3ac-4948-8713-ea84fdc72121',
  batches_count: 10,
  records: [],
  complete: false
}
```

See the [Record Webhook Format](#record-webhook-format) for more details on the payload.

### Step 2: Your servers tell Fuse when each batch is processed
Due to the nature of the record webhook flow being processed in real-time as the user is submitting an import, it's important to communicate the progress of each batch to Fuse. Doing this allows Fuse to show an accurate progress bar to the end user who is submitting data.

There are two ways to tell Fuse that your system has finished processing a batch:

#### Option 1: Respond to the record webhook with a `complete` status
If you can process the batch of records inline in the HTTP webhook request, you can simply respond to the HTTP request with the following:

```javascript
{
  batch: {
    status: 'completed',
    validation_issues: [{
      record_slug: '8971a303-8989-4b43-bb0b-dadf48bbace3',
      validation_type: 'error',
      column_name: 'email',
      issue_description: 'Email already exists and must be unique.'
    }]
  }
}
```

Details of this payload format are the same as the [Batch Status Request Format](#batch-status-request-format).


#### Option 2: Send Fuse a webhook after the batch has been processed
If you need extra time to process a webhook outside of the record webhook HTTP request, respond to the record webhook with a status of processing:

```javascript
{
  batch: {
    status: 'processing'
  }
}
```

Then, you can send an HTTP request to Fuse to update the status of your batch. We call this a [Batch Status Request](#batch-status-request-format).

```javascript
PUT https://fuse.flatirons.com/api/v1/webhooks/batches/:batch_slug
Headers:
- Authorization: Bearer {API_KEY_TOKEN}
Body:
{
  batch: {
    status: 'completed',
    validation_issues: [{
      record_slug: 2,
      validation_type: 'error',
      column_name: 'email',
      issue_description: 'Email already exists and must be unique.'
    }]
  }
}
```

### Step 3: Your server tells Fuse when all batches have been processed
After all batches have been processed, you must tell Fuse so that we know that we are done with the Import.

The final batch that we send to your record webhook will have the `complete: true` set in the payload. After all batches are processed, send the following request.

```javascript
PUT https://fuse.flatirons.com/api/v1/webhooks/imports/:import_slug
Headers:
- Authorization: Bearer {API_KEY_TOKEN}
Body:
{
  status: 'records_processed'
}
```


## Record Webhook Format
Record webhooks are sent in POST requests to your servers with the following payload structure.

```javascript
{
  batch_slug: '77db4861-6205-4344-b234-2d3ca0f9439a',
  import_slug: '40724d56-d8e6-461f-8555-780f0d0eeae3',
  batches_count: 10,
  records: [],
  complete: false
}
```

## Batch Status Request Format
Batch status requests are sent to the Fuse servers to let Fuse know when a batch has been processed.

```javascript
PUT https://fuse.flatirons.com/api/v1/webhooks/batches/:batch_slug
Headers:
- Authorization: Bearer {API_KEY_TOKEN}
Body:
{
  batch: {
    status: 'completed',
    validation_issues: [{
      record_slug: 'ffd928c3-3459-43fb-a2e4-3f1b3ad5fc1f',
      validation_type: 'error',
      column_name: 'email',
      issue_description: 'Email already exists and must be unique.'
    }]
  }
}
```

## Record Webhook Implementation Example

In this example using Javascript and Express, we create an endpoint in your backend that initially receives the token `http_x_fuse_signature_256` containing the signature generated by Fuse and submitted to you. \
You can use this signature to confirm the authenticity of the data, then, compare the signature with a generated one using the payload and your secret key.

After that, we start validating the data, creating an empty array to store the possible issues, retrieving the `import_slug` for further usage and looping through the received data.

In this step, you can do any validation you may need with the data, such as checking property existence in your backend, API calls, comparing values, etc. \
For this example, we have two mock functions to simulate the data being validated: `validateIdExistsInTheBackend` and `validateEmailUniquenessInServer`.

If you need to create some issue to be shown in the UI after the webhook is processed, you can use this structure below:

```javascript
{
  import_slug: 'f50df76a-e5b9-4784-80ba-6ef27948e2ba',
  record_slug: 'cb28e820-8af5-4f3a-b01b-87f2eb3f5014',
  validation_type: 'error',
  column_name: 'id',
  issue_description: 'An error occurred for the ID column.',
}
```

- `import_slug` can be accessed through `req.body.import_slug`.
- `record_slug` can be accessed from the current position of the `req.body.records` array, doing `req.body.records[index].slug`.
- `validation_type` can be "error" or "warning".
- `column_name` should be the exact `internal_key` you defined in your Template columns implementation that you want to attach the validation.
- `issue_description` is the message you want to show in the UI after the webhooks are processed.

Finally, we send a response from our webhook to Fuse in the request done, sending the batch status as completed and sending the `validation_issues`.

```javascript
router.post('/record-webhook', async (req, res) => {
  // Retrieve the signature from the headers
  const receivedSignature = req.headers['http_x_fuse_signature_256'];

  // Compute a signature using the payload and your secret key
  const expectedSignature = crypto
    .createHmac('sha256', secretKey)
    .update(JSON.stringify(req.body))
    .digest('hex');

  // Compare the signatures
  if (receivedSignature !== expectedSignature) {
    return res.status(401).send('Mismatched signatures');
  }

  // Validate the data
  const issues = [];
  const importSlug = req.body.import_slug;

  for (const record of req.body.records) {
    // Do any validation with your data. ID, for example:
    const errorMessageForId = await validateIdExistsInTheBackend(
      record.data.id
    );

    if (errorMessageForId) {
      issues.push({
        import_slug: importSlug,
        record_slug: record.slug,
        validation_type: 'error',
        column_name: 'id',
        issue_description: errorMessageForId,
      });
    }

    // Validate the email in your backend
    const errorMessageForEmail = await validateEmailUniquenessInServer(
      record.data.email
    );

    if (errorMessageForEmail) {
      issues.push({
        import_slug: importSlug,
        record_slug: record.slug,
        validation_type: 'error',
        column_name: 'email',
        issue_description: errorMessageForEmail,
      });
    }
  }

  res.json({ batch: { status: 'completed', validation_issues: issues } });
});
```
